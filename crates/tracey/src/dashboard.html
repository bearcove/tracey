<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  <title>tracey</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNiIgZmlsbD0iIzFhMWIyNiIvPjxwYXRoIGQ9Ik04IDI0IEwxNCA4IEwxOCAxNiBMMjQgOCIgc3Ryb2tlPSIjN2FhMmY3IiBzdHJva2Utd2lkdGg9IjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZmlsbD0ibm9uZSIvPjxjaXJjbGUgY3g9IjgiIGN5PSIyNCIgcj0iMi41IiBmaWxsPSIjNzNkYWNhIi8+PGNpcmNsZSBjeD0iMjQiIGN5PSI4IiByPSIyLjUiIGZpbGw9IiM3M2RhY2EiLz48L3N2Zz4=">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,500;0,600;1,400&family=Public+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <script type="importmap">
  {
    "imports": {
      "preact": "https://esm.sh/preact@10.25.4",
      "preact/hooks": "https://esm.sh/preact@10.25.4/hooks",
      "htm": "https://esm.sh/htm@3.1.1",
      "marked": "https://esm.sh/marked@15.0.6",
      "@arborium/arborium": "https://esm.sh/@arborium/arborium"
    }
  }
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@arborium/arborium@2.4.6/dist/themes/base.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@arborium/arborium@2.4.6/dist/themes/kanagawa-dragon.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@arborium/arborium@2.4.6/dist/themes/melange-light.css">
  <script src="https://cdn.jsdelivr.net/npm/lucide@0.469.0/dist/umd/lucide.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/devicon.min.css">
  <style>
    :root {
      color-scheme: light dark;
      --bg: light-dark(#f8f9fa, #13141a);
      --bg-secondary: light-dark(#ffffff, #1a1b26);
      --bg-sidebar: light-dark(#f3f4f6, #16171d);
      --fg: light-dark(#1a1b26, #c0caf5);
      --fg-muted: var(--arb-c);
      --fg-dim: var(--arb-v);
      --border: light-dark(#e5e5e5, #292e42);
      --hover: light-dark(#f0f0f2, #1f2335);
      --hover-subtle: light-dark(#f8f8fa, #1a1d2a);
      --accent: var(--arb-tu);
      --accent-dim: color-mix(in srgb, var(--arb-tu) 15%, transparent);
      --green: var(--arb-da);
      --green-dim: color-mix(in srgb, var(--arb-da) 15%, transparent);
      --red: var(--arb-dd);
      --red-dim: color-mix(in srgb, var(--arb-dd) 15%, transparent);
      --yellow: var(--arb-n);
      --yellow-dim: color-mix(in srgb, var(--arb-n) 15%, transparent);
      --purple: var(--arb-s);
      --bg-outer: light-dark(#e5e7eb, #0d0e12);

      --max-width: 1200px;

      /* Arborium syntax highlighting colors (combined light/dark) */
      --arb-at: light-dark(var(--arb-at-light), var(--arb-at-dark));
      --arb-co: light-dark(var(--arb-co-light), var(--arb-co-dark));
      --arb-fb: light-dark(var(--arb-fb-light), var(--arb-fb-dark));
      --arb-f: light-dark(var(--arb-f-light), var(--arb-f-dark));
      --arb-k: light-dark(var(--arb-k-light), var(--arb-k-dark));
      --arb-o: light-dark(var(--arb-o-light), var(--arb-o-dark));
      --arb-pr: light-dark(var(--arb-pr-light), var(--arb-pr-dark));
      --arb-p: light-dark(var(--arb-p-light), var(--arb-p-dark));
      --arb-s: light-dark(var(--arb-s-light), var(--arb-s-dark));
      --arb-tg: light-dark(var(--arb-tg-light), var(--arb-tg-dark));
      --arb-err: light-dark(var(--arb-err-light), var(--arb-err-dark));
      --arb-t: light-dark(var(--arb-t-light), var(--arb-t-dark));
      --arb-v: light-dark(var(--arb-v-light), var(--arb-v-dark));
      --arb-c: light-dark(var(--arb-c-light), var(--arb-c-dark));
      --arb-m: light-dark(var(--arb-m-light), var(--arb-m-dark));
      --arb-l: light-dark(var(--arb-l-light), var(--arb-l-dark));
      --arb-da: light-dark(var(--arb-da-light), var(--arb-da-dark));
      --arb-dd: light-dark(var(--arb-dd-light), var(--arb-dd-dark));
      --arb-n: light-dark(var(--arb-n-light), var(--arb-n-dark));
      --arb-tl: light-dark(var(--arb-tl-light), var(--arb-tl-dark));
      --arb-tu: light-dark(var(--arb-tu-light), var(--arb-tu-dark));
      --arb-tr: light-dark(var(--arb-tr-light), var(--arb-tr-dark));
      --arb-se: light-dark(var(--arb-se-light), var(--arb-se-dark));
      --arb-tt: light-dark(var(--arb-tt-light), var(--arb-tt-dark));
      --arb-ch: light-dark(var(--arb-ch-light), var(--arb-ch-dark));
      --arb-sr: light-dark(var(--arb-sr-light), var(--arb-sr-dark));
      --arb-bo: light-dark(var(--arb-bo-light), var(--arb-bo-dark));
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Public Sans', system-ui, -apple-system, sans-serif;
      background: var(--bg-outer);
      color: var(--fg);
      line-height: 1.5;
    }

    #app { min-height: 100vh; display: flex; flex-direction: column; }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      color: var(--fg-muted);
      font-size: 0.9rem;
    }

    /* Layout */
    .layout {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: var(--max-width);
      max-width: 100%;
      margin: 0 auto;
      background: var(--bg);
      border-left: 1px solid var(--border);
      border-right: 1px solid var(--border);
    }

    .header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      position: relative;
      z-index: 100;
    }

    .header-inner {
      display: flex;
      align-items: stretch;
      width: 100%;
      margin-bottom: -1px; /* tabs overlap the border */
    }

    .logo {
      font-weight: 600;
      font-size: 1.1rem;
      color: var(--fg);
      text-decoration: none;
      display: flex;
      align-items: center;
      padding: 0.75rem 1.25rem;
      margin-left: auto;
    }

    .logo:hover {
      background: var(--hover-subtle);
    }

    .nav {
      display: flex;
    }

    .nav-tab {
      padding: 0.75rem 1.25rem;
      background: transparent;
      color: var(--fg-muted);
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      font-size: 0.9rem;
      font-family: inherit;
      transition: all 0.15s;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .nav-tab:hover {
      background: var(--hover-subtle);
      color: var(--fg);
    }

    .nav-tab.active {
      color: var(--accent);
      border-bottom: 2px solid var(--accent);
      background: var(--bg);
    }

    .nav-tab .tab-icon {
      display: flex;
    }

    .nav-tab .tab-icon svg {
      width: 1em;
      height: 1em;
      stroke-width: 1.5;
    }

    .search-box {
      flex: 1;
      max-width: 400px;
      margin-left: auto;
    }

    .search-input {
      width: 100%;
      padding: 0.5rem 0.75rem;
      background: var(--bg);
      color: var(--fg);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 0.85rem;
      font-family: inherit;
    }

    .search-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-dim);
    }

    .search-input::placeholder {
      color: var(--fg-dim);
    }

    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
      width: 100%;
    }

    /* Stats bar */
    .stats-bar {
      display: flex;
      align-items: center;
      gap: 2rem;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      width: 100%;
      position: relative;
      z-index: 50;
    }

    .stat {
      display: flex;
      flex-direction: column;
      gap: 0.125rem;
    }

    .stat-label {
      font-size: 0.75rem;
      color: var(--fg-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .stat-value {
      font-size: 1.25rem;
      font-weight: 600;
      font-family: 'IBM Plex Mono', monospace;
    }

    .stat-value.good { color: var(--green); }
    .stat-value.warn { color: var(--yellow); }
    .stat-value.bad { color: var(--red); }

    .stat.clickable {
      cursor: pointer;
      padding: 0.5rem;
      margin: -0.5rem;
      border-radius: 6px;
      transition: background 0.15s;
    }

    .stat.clickable:hover {
      background: var(--hover);
    }

    .stats-controls {
      display: flex;
      gap: 0.75rem;
      margin-left: auto;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      border-right: 1px solid var(--border);
      background: var(--bg-sidebar);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .sidebar-header {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      font-weight: 500;
      font-size: 0.85rem;
      color: var(--fg-muted);
    }

    .sidebar-content {
      flex: 1;
      overflow-y: auto;
    }

    /* File tree */
    .file-tree {
      padding: 0.5rem;
    }

    .tree-folder {
      user-select: none;
    }

    .tree-folder-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.25rem;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--fg);
    }

    .tree-folder-header:hover {
      background: var(--hover);
    }

    .tree-folder-left {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .tree-folder-icon {
      width: 1rem;
      height: 1rem;
      color: var(--fg-dim);
      transition: transform 0.15s;
    }

    .tree-folder.open > .tree-folder-header .tree-folder-icon {
      transform: rotate(90deg);
    }

    .folder-badge {
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 4px;
      font-weight: 500;
    }
    .folder-badge.full { background: var(--green-dim); color: var(--green); }
    .folder-badge.partial { background: var(--yellow-dim); color: var(--yellow); }
    .folder-badge.none { background: var(--red-dim); color: var(--red); }

    .tree-folder-children {
      display: none;
      padding-left: 1rem;
    }

    .tree-folder.open > .tree-folder-children {
      display: block;
    }

    .tree-file {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0.5rem;
      padding-left: 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
    }

    .tree-file-icon {
      width: 1rem;
      height: 1rem;
      flex-shrink: 0;
      opacity: 0.8;
    }

    .tree-file-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tree-file-badge {
      flex-shrink: 0;
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 4px;
      font-weight: 500;
    }

    .tree-file:hover {
      background: var(--hover);
    }

    .tree-file.selected {
      background: var(--accent-dim);
      color: var(--accent);
    }

    .tree-file-badge.full { background: var(--green-dim); color: var(--green); }
    .tree-file-badge.partial { background: var(--yellow-dim); color: var(--yellow); }
    .tree-file-badge.none { background: var(--red-dim); color: var(--red); }

    /* Content area */
    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--bg);
    }

    .content-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.5rem 1rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
    }

    .content-body {
      flex: 1;
      overflow: auto;
    }

    /* Code view */
    .code-view {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      line-height: 1.6;
    }

    .code-line {
      display: flex;
      min-height: 1.5em;
    }

    .code-line:hover {
      background: var(--hover-subtle);
    }

    .code-line.highlighted {
      background: var(--yellow-dim);
    }

    .line-number {
      width: 4rem;
      padding: 0 0.75rem 0 0.5rem;
      text-align: right;
      color: var(--fg-dim);
      user-select: none;
      flex-shrink: 0;
      cursor: pointer;
      position: relative;
      border-left: 3px solid transparent;
    }

    .code-line.covered .line-number {
      border-left-color: var(--green);
    }

    .code-line.uncovered .line-number {
      border-left-color: var(--red);
    }

    .line-number:hover {
      color: var(--accent);
    }

    .line-popover {
      position: absolute;
      left: 100%;
      top: 50%;
      transform: translateY(-50%);
      margin-left: 0.5rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 100;
      white-space: nowrap;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .popover-btn {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      color: var(--fg);
      text-decoration: none;
      font-size: 0.8rem;
    }

    .popover-btn:hover {
      background: var(--hover);
    }

    .popover-btn i {
      font-size: 1rem;
    }

    .popover-btn .editor-icon-svg {
      width: 1rem;
      height: 1rem;
    }

    .line-content {
      flex: 1;
      padding-right: 1rem;
      white-space: pre;
    }

    .line-annotations {
      padding: 0 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      position: relative;
    }

    .annotation-count {
      font-size: 0.6rem;
      min-width: 1.2em;
      height: 1.2em;
      padding: 0 0.25rem;
      border-radius: 3px;
      background: var(--accent-dim);
      color: var(--accent);
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .annotation-badges {
      display: none;
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.25rem;
      gap: 0.25rem;
      flex-wrap: wrap;
      max-width: 300px;
      z-index: 50;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .line-annotations:hover .annotation-badges {
      display: flex;
    }

    .line-annotations:hover .annotation-count {
      display: none;
    }

    .annotation-badge {
      font-size: 0.65rem;
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      background: var(--accent-dim);
      color: var(--accent);
      font-weight: 500;
      white-space: nowrap;
      text-decoration: none;
      cursor: pointer;
      transition: all 0.15s;
    }

    a.annotation-badge:hover {
      background: var(--accent);
      color: white;
    }

    /* Rules table */
    .rules-table {
      width: 100%;
      border-collapse: collapse;
    }

    .rules-table th {
      text-align: left;
      padding: 0.75rem 1rem;
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--fg-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .rules-table td {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      vertical-align: top;
    }

    .rules-table tr:hover td {
      background: var(--hover-subtle);
    }

    .rule-id {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--accent);
    }

    .rule-text {
      font-size: 0.85rem;
      color: var(--fg-muted);
      margin-top: 0.25rem;
    }

    .rule-text code {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 90%;
      background: var(--hover);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
    }

    .rule-refs {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.8rem;
    }

    .rule-ref {
      display: block;
      color: var(--fg-muted);
      text-decoration: none;
      padding: 0.125rem 0;
    }

    .rule-ref:hover {
      color: var(--accent);
    }

    .rule-ref.impl { color: var(--green); }
    .rule-ref.verify { color: var(--accent); }

    /* Split view */
    .split-view {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .split-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-width: 0;
    }

    .split-pane + .split-pane {
      border-left: 1px solid var(--border);
    }

    .split-pane-header {
      padding: 0.5rem 1rem;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      font-size: 0.85rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .split-pane-content {
      flex: 1;
      overflow: auto;
    }

    /* Markdown content */
    .markdown {
      padding: 0.75rem 2rem 1.5rem 2rem;
      font-size: 0.9rem;
      line-height: 1.7;
    }

    .markdown h1, .markdown h2, .markdown h3, .markdown h4 {
      margin: 1.5rem 0 0.75rem;
      font-weight: 600;
      color: var(--fg);
      cursor: pointer;
    }

    .markdown h1:hover, .markdown h2:hover, .markdown h3:hover, .markdown h4:hover {
      color: var(--accent);
    }

    .markdown h1 { font-size: 1.5rem; }
    .markdown h2 { font-size: 1.25rem; }
    .markdown h3 { font-size: 1.1rem; }

    .markdown p {
      margin: 0.75rem 0;
    }

    .markdown code {
      font-family: 'IBM Plex Mono', monospace;
      background: var(--hover);
      padding: 0.15rem 0.35rem;
      border-radius: 4px;
      font-size: 0.85em;
    }

    .markdown pre {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 1rem;
      overflow-x: auto;
      margin: 1rem 0;
    }

    .markdown pre code {
      background: none;
      padding: 0;
    }

    .markdown ul, .markdown ol {
      margin: 0.75rem 0;
      padding-left: 1.5rem;
    }

    .markdown li {
      margin: 0.25rem 0;
    }

    .markdown blockquote {
      border-left: 3px solid var(--accent);
      margin: 1rem 0;
      padding-left: 1rem;
      color: var(--fg-muted);
    }

    /* RFC 2119 keyword highlighting */
    kw-must, kw-must-not, kw-required, kw-shall, kw-shall-not {
      color: var(--red);
      font-weight: 600;
    }
    kw-should, kw-should-not, kw-recommended, kw-not-recommended {
      color: var(--yellow);
      font-weight: 600;
    }
    kw-may, kw-optional {
      color: var(--accent);
      font-weight: 600;
    }

    /* Rule marker in spec */
    .rule-marker {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      width: fit-content;
      background: var(--accent-dim);
      color: var(--accent);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      margin: 0.15rem 0;
      text-decoration: none;
    }

    a.rule-marker:hover {
      filter: brightness(1.1);
    }

    .rule-marker-icon {
      width: 0.9em;
      height: 0.9em;
      flex-shrink: 0;
    }

    .rule-marker.covered {
      background: var(--green-dim);
      color: var(--green);
    }

    .rule-marker.partial {
      background: var(--yellow-dim);
      color: var(--yellow);
    }

    .rule-marker.uncovered {
      background: var(--red-dim);
      color: var(--red);
    }

    .rule-marker-highlighted {
      animation: rule-highlight-pulse 3s ease-out;
    }

    @keyframes rule-highlight-pulse {
      0%, 20% {
        box-shadow: 0 0 0 4px var(--accent);
        transform: scale(1.05);
      }
      100% {
        box-shadow: 0 0 0 0 transparent;
        transform: scale(1);
      }
    }

    /* Rule block - fieldset-like container */
    .rule-block {
      position: relative;
      border: 1px solid var(--border);
      border-radius: 6px;
      margin: 1rem 0 1.5rem 0;
      padding: 1rem 1rem 0.5rem 1rem;
    }

    .rule-block-covered { border-color: color-mix(in srgb, var(--green) 40%, var(--border)); }
    .rule-block-partial { border-color: color-mix(in srgb, var(--yellow) 40%, var(--border)); }
    .rule-block-uncovered { border-color: color-mix(in srgb, var(--red) 40%, var(--border)); }

    .rule-block-header {
      position: absolute;
      top: -0.65rem;
      left: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--bg);
      padding: 0 0.35rem;
    }

    .rule-block-header .rule-marker {
      margin: 0;
    }

    .rule-block-header .spec-refs {
      margin: 0;
      font-size: 0.7rem;
    }

    .rule-block-content {
      margin-top: 0.25rem;
    }

    .rule-block-content p:first-child {
      margin-top: 0;
    }

    .rule-block-content p:last-child {
      margin-bottom: 0;
    }

    .spec-refs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin: 0.25rem 0 0.5rem 0;
      font-size: 0.75rem;
    }

    .spec-ref {
      font-family: 'IBM Plex Mono', monospace;
      text-decoration: none;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
    }

    .spec-ref:hover {
      border-color: var(--accent);
    }

    .spec-ref-icon {
      width: 0.9em;
      height: 0.9em;
      flex-shrink: 0;
    }

    .spec-ref-icon-impl {
      color: var(--green);
    }

    .spec-ref-icon-verify {
      color: var(--accent);
    }

    .spec-ref-impl {
      color: var(--green);
    }

    .spec-ref-verify {
      color: var(--accent);
    }

    /* Empty state */
    .empty-state {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--fg-muted);
      font-size: 0.9rem;
    }


    /* Custom dropdowns */
    .custom-dropdown {
      position: relative;
      display: inline-block;
    }
    .dropdown-selected {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.4rem 0.6rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85rem;
      color: var(--fg);
      min-width: 90px;
    }
    .dropdown-selected:hover {
      background: var(--hover);
    }
    .dropdown-selected svg {
      width: 1rem;
      height: 1rem;
      flex-shrink: 0;
    }
    .dropdown-selected svg path {
      fill: currentColor;
    }
    .dropdown-selected .chevron {
      margin-left: auto;
      opacity: 0.5;
    }
    .dropdown-selected .chevron path {
      fill: none;
      stroke: currentColor;
    }
    .dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 4px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 100;
      min-width: 100%;
      display: none;
    }
    .custom-dropdown.open .dropdown-menu {
      display: block;
    }
    .dropdown-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85rem;
      color: var(--fg-muted);
      white-space: nowrap;
    }
    .dropdown-option:first-child {
      border-radius: 5px 5px 0 0;
    }
    .dropdown-option:last-child {
      border-radius: 0 0 5px 5px;
    }
    .dropdown-option:hover {
      background: var(--hover);
    }
    .dropdown-option.active {
      background: var(--hover);
      color: var(--fg);
    }
    .dropdown-option svg {
      width: 1rem;
      height: 1rem;
      flex-shrink: 0;
    }
    .dropdown-option svg path {
      fill: currentColor;
    }

    /* Level dots */
    .level-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .level-dot-all { background: var(--fg-muted); }
    .level-dot-must { background: var(--red); }
    .level-dot-should { background: var(--yellow); }
    .level-dot-may { background: var(--accent); }

    /* File reference styling */
    .ref-line {
      white-space: nowrap;
      margin-bottom: 0.35rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }
    .ref-line:last-child {
      margin-bottom: 0;
    }
    .ref-icon {
      width: 1.1em;
      height: 1.1em;
      flex-shrink: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .ref-icon svg {
      width: 100%;
      height: 100%;
    }
    .ref-icon-impl { color: var(--green); }
    .ref-icon-verify { color: var(--accent); }

    /* FilePath component */
    .file-path-link, .file-path-display {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      text-decoration: none;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.8em;
    }
    .file-path-link:hover .file-path-name {
      text-decoration: underline;
    }
    .file-path-icon {
      width: 1em;
      height: 1em;
      flex-shrink: 0;
      color: var(--fg-muted);
    }
    .file-path-icon-impl { color: var(--green); }
    .file-path-icon-verify { color: var(--accent); }
    .file-path-text {
      display: inline;
    }
    .file-path-dir {
      color: var(--fg-dim);
    }
    .file-path-name {
      color: var(--accent);
    }
    .file-path-line {
      color: var(--green);
    }

    /* Legacy file-link styles (for backwards compat) */
    .file-link {
      text-decoration: none;
      display: inline-flex;
    }
    .file-link:hover .file-name {
      text-decoration: underline;
    }
    .file-path {
      color: var(--fg-dim);
    }
    .file-name {
      color: var(--accent);
    }
    .file-line {
      color: var(--green);
    }



    /* Header controls */
    .header-controls {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-left: auto;
    }

    /* Rule ID with icon */
    .rule-id-row {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }
    .rule-icon {
      width: 1em;
      height: 1em;
      color: var(--fg-dim);
      flex-shrink: 0;
    }

    /* Outline tree */
    .outline-tree {
      padding: 0.5rem;
    }

    .outline-item {
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--fg-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .outline-item:hover {
      background: var(--hover);
      color: var(--fg);
    }

    .outline-item.active {
      background: var(--accent-dim);
      color: var(--accent);
    }

    .outline-level-1 { padding-left: 0.5rem; font-weight: 500; }
    .outline-level-2 { padding-left: 1.25rem; }
    .outline-level-3 { padding-left: 2rem; }
    .outline-level-4 { padding-left: 2.75rem; font-size: 0.8rem; }

    /* Search results */
    .search-results {
      flex: 1;
      overflow-y: auto;
      background: var(--bg);
    }

    .search-result {
      padding: 0.5rem 1rem;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.8rem;
    }

    .search-result:hover {
      background: var(--hover);
    }

    .search-result-file {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      margin-bottom: 0.25rem;
    }

    .search-result-path {
      color: var(--fg-dim);
    }

    .search-result-name {
      color: var(--accent);
    }

    .search-result-line {
      color: var(--green);
    }

    .search-result-content {
      color: var(--fg-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .search-result-highlight {
      background: var(--yellow-dim);
      color: var(--yellow);
      padding: 0.1rem 0.2rem;
      border-radius: 2px;
    }

    .search-empty {
      padding: 2rem;
      text-align: center;
      color: var(--fg-muted);
    }

    .search-loading {
      padding: 1rem;
      text-align: center;
      color: var(--fg-muted);
      font-size: 0.85rem;
    }

    /* Rule context panel */
    .rule-context {
      border: 1px solid var(--border);
      border-radius: 6px;
      margin: 0.5rem;
      background: var(--bg);
    }

    .rule-context-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0.75rem;
      background: var(--accent-dim);
      border-radius: 5px 5px 0 0;
      border-bottom: 1px solid var(--border);
    }

    .rule-context-id {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--accent);
    }

    .rule-context-close {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--fg-muted);
      padding: 0.25rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
    }

    .rule-context-close:hover {
      background: var(--hover);
      color: var(--fg);
    }

    .rule-context-body {
      padding: 0.75rem;
    }

    .rule-context-text {
      font-size: 0.85rem;
      color: var(--fg-muted);
      margin-bottom: 0.75rem;
      line-height: 1.5;
    }

    .rule-context-refs {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .rule-context-ref {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.8rem;
      cursor: pointer;
      text-decoration: none;
      color: var(--fg);
    }

    .rule-context-ref:hover {
      background: var(--hover);
    }

    .rule-context-ref.active {
      background: var(--accent-dim);
    }

    .rule-context-back {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      margin-top: 0.75rem;
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      color: var(--fg-muted);
      text-decoration: none;
    }

    .rule-context-back:hover {
      background: var(--hover);
      color: var(--fg);
    }

    /* Global search overlay */
    .search-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 10vh;
      z-index: 1000;
    }

    .search-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      width: 600px;
      max-width: 90vw;
      max-height: 70vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .search-modal-input {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .search-modal-input input {
      width: 100%;
      padding: 0.75rem 1rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 1rem;
      color: var(--fg);
      font-family: inherit;
    }

    .search-modal-input input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-dim);
    }

    .search-modal-results {
      flex: 1;
      overflow-y: auto;
    }

    .search-modal-result {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
    }

    .search-modal-result:hover {
      background: var(--hover);
    }

    .search-modal-result-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.25rem;
    }

    .search-result-icon {
      width: 1.1rem;
      height: 1.1rem;
      flex-shrink: 0;
    }

    .search-result-icon.source {
      color: var(--green);
    }

    .search-result-icon.rule {
      color: var(--accent);
    }

    .search-modal-result-id {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      color: var(--accent);
    }

    .search-modal-result-line {
      color: var(--green);
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
    }

    .search-modal-result-content {
      font-size: 0.85rem;
      color: var(--fg-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .search-modal-empty {
      padding: 2rem;
      text-align: center;
      color: var(--fg-muted);
    }

    .search-modal-hint {
      padding: 0.75rem 1rem;
      border-top: 1px solid var(--border);
      font-size: 0.75rem;
      color: var(--fg-dim);
      display: flex;
      gap: 1rem;
    }

    .search-modal-hint kbd {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 0.1rem 0.35rem;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.7rem;
    }

    .search-modal-result-code {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      line-height: 1.6;
      margin: 0;
      padding: 0.25rem 0;
      background: transparent;
      white-space: pre;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--fg-muted);
    }

    .search-modal-result-code code {
      background: none;
      padding: 0;
    }
    
    .search-modal-result-code mark,
    .search-modal-result-content mark {
      background: var(--yellow-dim);
      color: var(--yellow);
      padding: 0.1em 0.2em;
      border-radius: 2px;
    }

    .search-modal-result.selected {
      background: var(--accent-dim);
    }
  </style>
</head>
<body>
  <div id="app"><div class="loading">Loading...</div></div>
  <script type="module">
    import { h, render, Fragment } from 'preact';
    import { useState, useEffect, useMemo, useCallback, useRef } from 'preact/hooks';
    import htm from 'htm';
    import { marked } from 'marked';
    import { highlight } from '@arborium/arborium';

    const html = htm.bind(h);

    // Cache for highlighted code
    const highlightCache = new Map();

    // ========================================================================
    // API
    // ========================================================================

    async function fetchJson(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    // ========================================================================
    // Routing
    // ========================================================================

    function parseRoute() {
      const path = window.location.pathname;
      const params = new URLSearchParams(window.location.search);

      // /sources or /sources/path/to/file.rs:123
      if (path === '/sources' || path.startsWith('/sources/')) {
        const rest = path.length > 9 ? path.slice(9) : ''; // Remove '/sources/'
        const context = params.get('context'); // rule ID context
        if (rest) {
          const colonIdx = rest.lastIndexOf(':');
          if (colonIdx !== -1) {
            const file = rest.slice(0, colonIdx);
            const line = parseInt(rest.slice(colonIdx + 1), 10);
            return { view: 'sources', file, line: isNaN(line) ? null : line, context };
          }
          return { view: 'sources', file: rest, line: null, context };
        }
        return { view: 'sources', file: null, line: null, context };
      }
      // /spec or /spec/rule.id
      if (path.startsWith('/spec')) {
        const rule = path.length > 5 ? path.slice(6) : params.get('rule');
        return { view: 'spec', rule };
      }
      // /coverage (or /forward for backwards compatibility, or default)
      return {
        view: 'coverage',
        filter: params.get('filter'), // 'impl' or 'verify' or null
        level: params.get('level'), // 'must', 'should', 'may', or null (all)
      };
    }

    function buildUrl(view, params = {}) {
      if (view === 'sources') {
        const { file, line, context } = params;
        let url = '/sources';
        if (file) {
          url = line ? `/sources/${file}:${line}` : `/sources/${file}`;
        }
        if (context) {
          url += `?context=${encodeURIComponent(context)}`;
        }
        return url;
      }
      if (view === 'spec') {
        const { rule } = params;
        return rule ? `/spec/${rule}` : '/spec';
      }
      // coverage
      const searchParams = new URLSearchParams();
      if (params.filter) searchParams.set('filter', params.filter);
      if (params.level && params.level !== 'all') searchParams.set('level', params.level);
      const query = searchParams.toString();
      return `/coverage${query ? '?' + query : ''}`;
    }

    function navigate(view, params = {}, replace = false) {
      const url = buildUrl(view, params);
      if (replace) {
        history.replaceState(null, '', url);
      } else {
        history.pushState(null, '', url);
      }
      window.dispatchEvent(new PopStateEvent('popstate'));
    }

    function useRouter() {
      const [route, setRoute] = useState(parseRoute);

      useEffect(() => {
        const handlePopState = () => setRoute(parseRoute());
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);

      return route;
    }

    // ========================================================================
    // Hooks
    // ========================================================================

    function useApi() {
      const [data, setData] = useState(null);
      const [error, setError] = useState(null);
      const [version, setVersion] = useState(null);

      const fetchData = useCallback(async () => {
        try {
          const [config, forward, reverse] = await Promise.all([
            fetchJson('/api/config'),
            fetchJson('/api/forward'),
            fetchJson('/api/reverse'),
          ]);
          setData({ config, forward, reverse });
          setError(null);
        } catch (e) {
          setError(e.message);
        }
      }, []);

      // Initial fetch
      useEffect(() => {
        fetchData();
      }, [fetchData]);

      // Poll for version changes and refetch if changed
      useEffect(() => {
        let active = true;
        let lastVersion = null;

        async function poll() {
          if (!active) return;
          try {
            const res = await fetchJson('/api/version');
            if (lastVersion !== null && res.version !== lastVersion) {
              console.log(`Version changed: ${lastVersion} -> ${res.version}, refetching...`);
              await fetchData();
            }
            lastVersion = res.version;
            setVersion(res.version);
          } catch (e) {
            console.warn('Version poll failed:', e);
          }
          if (active) setTimeout(poll, 500);
        }

        poll();
        return () => { active = false; };
      }, [fetchData]);

      return { data, error, version, refetch: fetchData };
    }

    function useFile(path) {
      const [file, setFile] = useState(null);

      useEffect(() => {
        if (!path) {
          setFile(null);
          return;
        }
        fetchJson('/api/file?path=' + encodeURIComponent(path))
          .then(setFile)
          .catch(e => {
            console.error('Failed to load file:', e);
            setFile(null);
          });
      }, [path]);

      return file;
    }

    function useSpec(name) {
      const [spec, setSpec] = useState(null);

      useEffect(() => {
        if (!name) {
          setSpec(null);
          return;
        }
        fetchJson('/api/spec?name=' + encodeURIComponent(name))
          .then(setSpec)
          .catch(e => {
            console.error('Failed to load spec:', e);
            setSpec(null);
          });
      }, [name]);

      return spec;
    }

    // ========================================================================
    // Utils
    // ========================================================================

    function buildFileTree(files) {
      const root = { name: '', children: {}, files: [], totalUnits: 0, coveredUnits: 0 };

      for (const file of files) {
        const parts = file.path.split('/');
        let current = root;

        for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (!current.children[part]) {
            current.children[part] = { name: part, children: {}, files: [], totalUnits: 0, coveredUnits: 0 };
          }
          current = current.children[part];
        }

        current.files.push({ ...file, name: parts[parts.length - 1] });
      }

      // Compute folder coverage recursively
      function computeCoverage(node) {
        let total = 0;
        let covered = 0;

        // Add files in this folder
        for (const f of node.files) {
          total += f.totalUnits || 0;
          covered += f.coveredUnits || 0;
        }

        // Add children folders
        for (const child of Object.values(node.children)) {
          computeCoverage(child);
          total += child.totalUnits;
          covered += child.coveredUnits;
        }

        node.totalUnits = total;
        node.coveredUnits = covered;
      }

      computeCoverage(root);
      return root;
    }

    function getCoverageBadge(covered, total) {
      if (total === 0) return { class: 'none', text: '-' };
      const pct = (covered / total) * 100;
      if (pct === 100) return { class: 'full', text: '100%' };
      if (pct >= 50) return { class: 'partial', text: Math.round(pct) + '%' };
      return { class: 'none', text: Math.round(pct) + '%' };
    }

    function getStatClass(pct) {
      if (pct >= 80) return 'good';
      if (pct >= 50) return 'warn';
      return 'bad';
    }

    // Render rule text with backticks -> <code> and RFC 2119 keywords highlighted
    function renderRuleText(text) {
      if (!text) return '';

      // Escape HTML first
      let result = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      // Process `code` (backticks)
      let inCode = false;
      let processed = '';
      for (const char of result) {
        if (char === '`') {
          if (inCode) {
            processed += '</code>';
            inCode = false;
          } else {
            processed += '<code>';
            inCode = true;
          }
        } else {
          processed += char;
        }
      }
      if (inCode) processed += '</code>';
      result = processed;

      // Wrap RFC 2119 keywords (order matters - longer phrases first)
      result = result
        .replace(/\bMUST NOT\b/g, '<kw-must-not>MUST NOT</kw-must-not>')
        .replace(/\bSHALL NOT\b/g, '<kw-shall-not>SHALL NOT</kw-shall-not>')
        .replace(/\bSHOULD NOT\b/g, '<kw-should-not>SHOULD NOT</kw-should-not>')
        .replace(/\bNOT RECOMMENDED\b/g, '<kw-not-recommended>NOT RECOMMENDED</kw-not-recommended>')
        .replace(/\bMUST\b/g, '<kw-must>MUST</kw-must>')
        .replace(/\bREQUIRED\b/g, '<kw-required>REQUIRED</kw-required>')
        .replace(/\bSHALL\b/g, '<kw-shall>SHALL</kw-shall>')
        .replace(/\bSHOULD\b/g, '<kw-should>SHOULD</kw-should>')
        .replace(/\bRECOMMENDED\b/g, '<kw-recommended>RECOMMENDED</kw-recommended>')
        .replace(/\bMAY\b/g, '<kw-may>MAY</kw-may>')
        .replace(/\bOPTIONAL\b/g, '<kw-optional>OPTIONAL</kw-optional>');

      return result;
    }

    // Highlight code using arborium (async, with caching)
    async function highlightCode(code, lang = 'rust') {
      const cacheKey = `${lang}:${code}`;
      if (highlightCache.has(cacheKey)) {
        return highlightCache.get(cacheKey);
      }
      try {
        const highlighted = await highlight(lang, code);
        highlightCache.set(cacheKey, highlighted);
        return highlighted;
      } catch (e) {
        console.warn('Highlight failed:', e);
        // Fallback: escape HTML
        return code
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }
    }

    // Split highlighted HTML into self-contained lines
    // Each line will have properly balanced open/close tags
    function splitHighlightedHtml(html) {
      // Use DOMParser for robust HTML parsing
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<div>${html}</div>`, 'text/html');
      const container = doc.body.firstChild;

      const lines = [];
      let currentLine = '';
      let openTags = []; // Stack of {tag, attrs}

      function processNode(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent;
          for (const char of text) {
            if (char === '\n') {
              // Close tags, push line, reopen tags
              for (let j = openTags.length - 1; j >= 0; j--) {
                currentLine += `</${openTags[j].tag}>`;
              }
              lines.push(currentLine);
              currentLine = '';
              for (const t of openTags) {
                currentLine += `<${t.tag}${t.attrs}>`;
              }
            } else {
              currentLine += char === '<' ? '&lt;' : char === '>' ? '&gt;' : char === '&' ? '&amp;' : char;
            }
          }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = node.tagName.toLowerCase();
          let attrs = '';
          for (const attr of node.attributes) {
            attrs += ` ${attr.name}="${attr.value.replace(/"/g, '&quot;')}"`;
          }

          currentLine += `<${tag}${attrs}>`;
          openTags.push({ tag, attrs });

          for (const child of node.childNodes) {
            processNode(child);
          }

          openTags.pop();
          currentLine += `</${tag}>`;
        }
      }

      for (const child of container.childNodes) {
        processNode(child);
      }

      // Push final line if any content remains
      if (currentLine) {
        lines.push(currentLine);
      }

      return lines;
    }

    // Hook to highlight a file and split into lines
    function useHighlightedLines(content, lang = 'rust') {
      const [lines, setLines] = useState(null);

      useEffect(() => {
        if (!content) {
          setLines(null);
          return;
        }

        let cancelled = false;

        highlightCode(content, lang).then(highlighted => {
          if (cancelled) return;
          // arborium wraps in <pre><code>...</code></pre>, extract inner content
          const match = highlighted.match(/<pre[^>]*><code[^>]*>([\s\S]*)<\/code><\/pre>/);
          const inner = match ? match[1] : highlighted;
          // Split into self-contained lines with balanced tags
          setLines(splitHighlightedHtml(inner));
        });

        return () => { cancelled = true; };
      }, [content, lang]);

      return lines;
    }

    // ========================================================================
    // Components
    // ========================================================================

    // Detect platform for keyboard shortcuts
    const isMac = typeof navigator !== 'undefined' && navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const modKey = isMac ? 'âŒ˜' : 'Ctrl';

    function App() {
      const { data, error, version } = useApi();
      const route = useRouter();
      const [search, setSearch] = useState('');
      const [scrollPositions, setScrollPositions] = useState({});
      const [searchOpen, setSearchOpen] = useState(false);

      if (error) return html`<div class="loading">Error: ${error}</div>`;
      if (!data) return html`<div class="loading">Loading...</div>`;

      const { config, forward, reverse } = data;
      const { view, file, rule, line, filter, context, level: routeLevel } = route;

      // Level comes from URL, defaults to 'all'
      const level = routeLevel || 'all';

      const handleLevelChange = useCallback((newLevel) => {
        navigate('coverage', { filter, level: newLevel }, false);
      }, [filter]);

      const handleViewChange = useCallback((newView) => {
        navigate(newView, {}, false);
      }, []);

      const handleSelectFile = useCallback((filePath, lineNum = null, ruleContext = null) => {
        navigate('sources', { file: filePath, line: lineNum, context: ruleContext }, false);
      }, []);

      const handleSelectRule = useCallback((ruleId) => {
        navigate('spec', { rule: ruleId }, false);
      }, []);

      const handleClearContext = useCallback(() => {
        navigate('sources', { file, line, context: null }, true);
      }, [file, line]);

      // Global keyboard shortcut for search
      useEffect(() => {
        const handleKeyDown = (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            setSearchOpen(true);
          }
          if (e.key === 'Escape') {
            setSearchOpen(false);
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []);

      const handleSearchSelect = useCallback((result) => {
        setSearchOpen(false);
        if (result.kind === 'rule') {
          navigate('spec', { rule: result.id }, false);
        } else {
          navigate('sources', { file: result.id, line: result.line }, false);
        }
      }, []);

      const handleFilterChange = useCallback((newFilter) => {
        navigate('coverage', { filter: newFilter, level }, false);
      }, [level]);

      return html`
        <div class="layout">
          <${Header}
            view=${view}
            onViewChange=${handleViewChange}
            onOpenSearch=${() => setSearchOpen(true)}
          />

          ${searchOpen && html`
            <${SearchModal}
              onClose=${() => setSearchOpen(false)}
              onSelect=${handleSearchSelect}
            />
          `}

          ${view === 'coverage' && html`
            <${CoverageView}
              data=${forward}
              config=${config}
              search=${search}
              onSearchChange=${setSearch}
              level=${level}
              onLevelChange=${handleLevelChange}
              filter=${filter}
              onFilterChange=${handleFilterChange}
              onSelectRule=${handleSelectRule}
              onSelectFile=${handleSelectFile}
            />
          `}

          ${view === 'sources' && html`
            <${SourcesView}
              data=${reverse}
              forward=${forward}
              config=${config}
              search=${search}
              onSearchChange=${setSearch}
              selectedFile=${file}
              selectedLine=${line}
              ruleContext=${context}
              onSelectFile=${handleSelectFile}
              onSelectRule=${handleSelectRule}
              onClearContext=${handleClearContext}
            />
          `}

          ${view === 'spec' && html`
            <${SpecView}
              config=${config}
              forward=${forward}
              selectedRule=${rule}
              onSelectRule=${handleSelectRule}
              onSelectFile=${handleSelectFile}
              scrollPosition=${scrollPositions.spec || 0}
              onScrollChange=${(pos) => setScrollPositions(prev => ({ ...prev, spec: pos }))}
            />
          `}
        </div>
      `;
    }

    // Editor configurations with devicon classes (zed uses inline SVG since devicon font doesn't have it yet)
    const ZED_SVG = `<svg class="editor-icon-svg" viewBox="0 0 128 128"><path fill="currentColor" d="M12 8a4 4 0 0 0-4 4v88H0V12C0 5.373 5.373 0 12 0h107.172c5.345 0 8.022 6.463 4.242 10.243L57.407 76.25H76V68h8v10.028a4 4 0 0 1-4 4H49.97l-13.727 13.729H98V56h8v47.757a8 8 0 0 1-8 8H27.657l-13.97 13.97H116a4 4 0 0 0 4-4V28h8v93.757c0 6.627-5.373 12-12 12H8.828c-5.345 0-8.022-6.463-4.242-10.243L70.343 57.757H52v8h-8V55.728a4 4 0 0 1 4-4h30.086l13.727-13.728H30V78h-8V30.243a8 8 0 0 1 8-8h70.343l13.97-13.971H12z"/></svg>`;
    const EDITORS = {
      zed: { name: 'Zed', urlTemplate: (path, line) => `zed://file/${path}:${line}`, icon: ZED_SVG },
      vscode: { name: 'VS Code', urlTemplate: (path, line) => `vscode://file/${path}:${line}`, devicon: 'devicon-vscode-plain' },
      idea: { name: 'IntelliJ', urlTemplate: (path, line) => `idea://open?file=${path}&line=${line}`, devicon: 'devicon-intellij-plain' },
      vim: { name: 'Vim', urlTemplate: (path, line) => `mvim://open?url=file://${path}&line=${line}`, devicon: 'devicon-vim-plain' },
      neovim: { name: 'Neovim', urlTemplate: (path, line) => `nvim://open?file=${path}&line=${line}`, devicon: 'devicon-neovim-plain' },
      emacs: { name: 'Emacs', urlTemplate: (path, line) => `emacs://open?url=file://${path}&line=${line}`, devicon: 'devicon-emacs-original' },
    };

    const LEVELS = {
      all: { name: 'All', dotClass: 'level-dot-all' },
      must: { name: 'MUST', dotClass: 'level-dot-must' },
      should: { name: 'SHOULD', dotClass: 'level-dot-should' },
      may: { name: 'MAY', dotClass: 'level-dot-may' },
    };

    // Map file extensions to devicon class names
    // See https://devicon.dev/ for available icons
    const LANG_DEVICON_MAP = {
      rs: 'devicon-rust-original',
      ts: 'devicon-typescript-plain',
      tsx: 'devicon-typescript-plain',
      js: 'devicon-javascript-plain',
      jsx: 'devicon-javascript-plain',
      py: 'devicon-python-plain',
      go: 'devicon-go-plain',
      c: 'devicon-c-plain',
      cpp: 'devicon-cplusplus-plain',
      h: 'devicon-c-plain',
      hpp: 'devicon-cplusplus-plain',
      swift: 'devicon-swift-plain',
      java: 'devicon-java-plain',
      rb: 'devicon-ruby-plain',
      md: 'devicon-markdown-original',
      json: 'devicon-json-plain',
      yaml: 'devicon-yaml-plain',
      yml: 'devicon-yaml-plain',
      toml: 'devicon-toml-plain',
      html: 'devicon-html5-plain',
      css: 'devicon-css3-plain',
      scss: 'devicon-sass-original',
      sass: 'devicon-sass-original',
      sh: 'devicon-bash-plain',
      bash: 'devicon-bash-plain',
      zsh: 'devicon-bash-plain',
      sql: 'devicon-postgresql-plain',
      kt: 'devicon-kotlin-plain',
      scala: 'devicon-scala-plain',
      hs: 'devicon-haskell-plain',
      ex: 'devicon-elixir-plain',
      exs: 'devicon-elixir-plain',
      erl: 'devicon-erlang-plain',
      clj: 'devicon-clojure-plain',
      php: 'devicon-php-plain',
      lua: 'devicon-lua-plain',
      r: 'devicon-r-plain',
      jl: 'devicon-julia-plain',
      dart: 'devicon-dart-plain',
      vue: 'devicon-vuejs-plain',
      svelte: 'devicon-svelte-plain',
      // Default fallback - use Lucide file icon
      default: null,
    };

    // Get devicon class for a file extension (returns null if no devicon available)
    function getDeviconClass(filePath) {
      const ext = filePath.split('.').pop()?.toLowerCase();
      return LANG_DEVICON_MAP[ext] || LANG_DEVICON_MAP.default;
    }

    // Language icon component - uses devicon if available, falls back to Lucide
    function LangIcon({ filePath, className = '' }) {
      const deviconClass = getDeviconClass(filePath);
      const iconRef = useRef(null);

      // For Lucide fallback
      useEffect(() => {
        if (!deviconClass && iconRef.current && typeof lucide !== 'undefined') {
          iconRef.current.innerHTML = '';
          const i = document.createElement('i');
          i.setAttribute('data-lucide', 'file');
          iconRef.current.appendChild(i);
          lucide.createIcons({ nodes: [i] });
        }
      }, [deviconClass]);

      if (deviconClass) {
        return html`<i class="${deviconClass} ${className}"></i>`;
      }
      return html`<span ref=${iconRef} class=${className}></span>`;
    }

    // Create a Lucide icon element (for use in htm templates)
    function LucideIcon({ name, className = '' }) {
      const iconRef = useRef(null);

      useEffect(() => {
        if (iconRef.current && typeof lucide !== 'undefined') {
          iconRef.current.innerHTML = '';
          const i = document.createElement('i');
          i.setAttribute('data-lucide', name);
          iconRef.current.appendChild(i);
          lucide.createIcons({ nodes: [i] });
        }
      }, [name]);

      return html`<span ref=${iconRef} class=${className}></span>`;
    }

    // Tab icon names (Lucide)
    const TAB_ICON_NAMES = {
      specification: 'file-text',
      coverage: 'bar-chart-3',
      sources: 'folder-open',
    };

    // Search result item component with syntax highlighting for source
    function SearchResultItem({ result, isSelected, onSelect, onHover }) {
      return html`
        <div
          class="search-modal-result ${isSelected ? 'selected' : ''}"
          onClick=${onSelect}
          onMouseEnter=${onHover}
        >
          <div class="search-modal-result-header">
            ${result.kind === 'source' ? html`
              <${FilePath} file=${result.id} line=${result.line > 0 ? result.line : null} type="source" />
            ` : html`
              <${LucideIcon} name="file-text" className="search-result-icon rule" />
              <span class="search-modal-result-id">${result.id}</span>
            `}
          </div>
          ${result.kind === 'source' ? html`
            <pre class="search-modal-result-code"><code dangerouslySetInnerHTML=${{ __html: result.highlighted || result.content.trim() }} /></pre>
          ` : html`
            <div class="search-modal-result-content" dangerouslySetInnerHTML=${{ __html: result.highlighted || result.content.trim() }} />
          `}
        </div>
      `;
    }

    function SearchModal({ onClose, onSelect }) {
      const [query, setQuery] = useState('');
      const [results, setResults] = useState(null);
      const [isSearching, setIsSearching] = useState(false);
      const [selectedIndex, setSelectedIndex] = useState(0);
      const inputRef = useRef(null);
      const resultsRef = useRef(null);
      const searchTimeoutRef = useRef(null);

      // Focus input on mount and initialize Lucide icons
      useEffect(() => {
        inputRef.current?.focus();
      }, []);

      // Re-render Lucide icons when results change
      useEffect(() => {
        if (results?.results?.length && typeof lucide !== 'undefined') {
          requestAnimationFrame(() => {
            lucide.createIcons();
          });
        }
      }, [results]);

      // Debounced search
      useEffect(() => {
        if (!query || query.length < 2) {
          setResults(null);
          setSelectedIndex(0);
          return;
        }

        setIsSearching(true);

        if (searchTimeoutRef.current) {
          clearTimeout(searchTimeoutRef.current);
        }

        searchTimeoutRef.current = setTimeout(async () => {
          try {
            const res = await fetch(`/api/search?q=${encodeURIComponent(query)}&limit=50`);
            const data = await res.json();
            setResults(data);
            setSelectedIndex(0);
          } catch (e) {
            console.error('Search failed:', e);
            setResults({ results: [] });
          } finally {
            setIsSearching(false);
          }
        }, 150);

        return () => {
          if (searchTimeoutRef.current) {
            clearTimeout(searchTimeoutRef.current);
          }
        };
      }, [query]);

      // Scroll selected item into view
      useEffect(() => {
        if (!resultsRef.current) return;
        const selected = resultsRef.current.querySelector('.search-modal-result.selected');
        if (selected) {
          selected.scrollIntoView({ block: 'nearest' });
        }
      }, [selectedIndex]);

      // Keyboard navigation
      const handleKeyDown = useCallback((e) => {
        if (!results?.results?.length) return;

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          setSelectedIndex(i => Math.min(i + 1, results.results.length - 1));
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          setSelectedIndex(i => Math.max(i - 1, 0));
        } else if (e.key === 'Enter') {
          e.preventDefault();
          const result = results.results[selectedIndex];
          if (result) onSelect(result);
        }
      }, [results, selectedIndex, onSelect]);

      // Close on backdrop click
      const handleBackdropClick = useCallback((e) => {
        if (e.target === e.currentTarget) {
          onClose();
        }
      }, [onClose]);

      return html`
        <div class="search-overlay" onClick=${handleBackdropClick}>
          <div class="search-modal">
            <div class="search-modal-input">
              <input
                ref=${inputRef}
                type="text"
                placeholder="Search code and rules..."
                value=${query}
                onInput=${(e) => setQuery(e.target.value)}
                onKeyDown=${handleKeyDown}
              />
            </div>
            <div class="search-modal-results" ref=${resultsRef}>
              ${isSearching ? html`
                <div class="search-modal-empty">Searching...</div>
              ` : results?.results?.length > 0 ? html`
                ${results.results.map((result, idx) => html`
                  <${SearchResultItem}
                    key=${result.kind + ':' + result.id + ':' + result.line}
                    result=${result}
                    isSelected=${idx === selectedIndex}
                    onSelect=${() => onSelect(result)}
                    onHover=${() => setSelectedIndex(idx)}
                  />
                `)}
              ` : query.length >= 2 ? html`
                <div class="search-modal-empty">No results found</div>
              ` : html`
                <div class="search-modal-empty">Type to search code and rules...</div>
              `}
            </div>
            <div class="search-modal-hint">
              <span><kbd>â†‘</kbd><kbd>â†“</kbd> Navigate</span>
              <span><kbd>Enter</kbd> Select</span>
              <span><kbd>Esc</kbd> Close</span>
            </div>
          </div>
        </div>
      `;
    }

    function Header({ view, onViewChange, onOpenSearch }) {
      const handleNavClick = (e, newView) => {
        e.preventDefault();
        onViewChange(newView);
      };

      return html`
        <header class="header">
          <div class="header-inner">
            <nav class="nav">
              <a
                href="/spec"
                class="nav-tab ${view === 'spec' ? 'active' : ''}"
                onClick=${(e) => handleNavClick(e, 'spec')}
              ><${LucideIcon} name=${TAB_ICON_NAMES.specification} className="tab-icon" /><span>Specification</span></a>
              <a
                href="/coverage"
                class="nav-tab ${view === 'coverage' ? 'active' : ''}"
                onClick=${(e) => handleNavClick(e, 'coverage')}
              ><${LucideIcon} name=${TAB_ICON_NAMES.coverage} className="tab-icon" /><span>Coverage</span></a>
              <a
                href="/sources"
                class="nav-tab ${view === 'sources' ? 'active' : ''}"
                onClick=${(e) => handleNavClick(e, 'sources')}
              ><${LucideIcon} name=${TAB_ICON_NAMES.sources} className="tab-icon" /><span>Sources</span></a>
            </nav>

            <div class="search-box" style="margin-left: auto; margin-right: 1rem; display: flex; align-items: center;">
              <input
                type="text"
                class="search-input"
                placeholder="Search... (${modKey}+K)"
                onClick=${onOpenSearch}
                onFocus=${(e) => { e.target.blur(); onOpenSearch(); }}
                readOnly
                style="cursor: pointer;"
              />
            </div>

            <a href="https://github.com/bearcove/tracey" class="logo" target="_blank" rel="noopener">tracey</a>
          </div>
        </header>
      `;
    }

    // Helper to split file path into dir and filename
    function splitPath(filePath) {
      const lastSlash = filePath.lastIndexOf('/');
      if (lastSlash === -1) return { dir: '', name: filePath };
      return { dir: filePath.slice(0, lastSlash + 1), name: filePath.slice(lastSlash + 1) };
    }

    // Universal file path display component
    // Props:
    //   file: file path
    //   line: optional line number
    //   short: if true, only show filename (not full path)
    //   type: 'impl' | 'verify' | 'source' - affects icon color
    //   onClick: optional click handler
    //   className: optional additional class
    function FilePath({ file, line, short = false, type = 'source', onClick, className = '' }) {
      const { dir, name } = splitPath(file);
      const iconClass = type === 'impl' ? 'file-path-icon-impl' : type === 'verify' ? 'file-path-icon-verify' : '';

      const content = html`
        <${LangIcon} filePath=${file} className="file-path-icon ${iconClass}" /><span class="file-path-text">${!short && dir ? html`<span class="file-path-dir">${dir}</span>` : ''}<span class="file-path-name">${name}</span>${line != null ? html`<span class="file-path-line">:${line}</span>` : ''}</span>
      `;

      if (onClick) {
        return html`
          <a
            class="file-path-link ${className}"
            href="#"
            onClick=${(e) => { e.preventDefault(); onClick(); }}
          >
            ${content}
          </a>
        `;
      }

      return html`<span class="file-path-display ${className}">${content}</span>`;
    }

    // File reference component (wrapper for backwards compatibility in coverage table)
    function FileRef({ file, line, type, onSelectFile }) {
      return html`
        <div class="ref-line">
          <${FilePath}
            file=${file}
            line=${line}
            type=${type}
            onClick=${() => onSelectFile(file, line)}
          />
        </div>
      `;
    }

    function CoverageView({ data, config, search, onSearchChange, level, onLevelChange, filter, onFilterChange, onSelectRule, onSelectFile }) {
      const [levelOpen, setLevelOpen] = useState(false);

      // Close dropdowns when clicking outside
      useEffect(() => {
        const handleClick = (e) => {
          if (!e.target.closest('#level-dropdown')) setLevelOpen(false);
        };
        document.addEventListener('click', handleClick);
        return () => document.removeEventListener('click', handleClick);
      }, []);

      const allRules = useMemo(() =>
        data.specs.flatMap(s => s.rules.map(r => ({ ...r, spec: s.name }))),
        [data]
      );

      // Infer level from rule text if not explicitly set
      const inferLevel = useCallback((rule) => {
        if (rule.level) return rule.level.toLowerCase();
        if (!rule.text) return null;
        const text = rule.text.toUpperCase();
        // Check for MUST NOT, SHALL NOT first (still MUST level)
        if (text.includes('MUST') || text.includes('SHALL') || text.includes('REQUIRED')) return 'must';
        if (text.includes('SHOULD') || text.includes('RECOMMENDED')) return 'should';
        if (text.includes('MAY') || text.includes('OPTIONAL')) return 'may';
        return null;
      }, []);

      const filteredRules = useMemo(() => {
        let rules = allRules;

        // Filter by level (explicit or inferred from text)
        if (level !== 'all') {
          rules = rules.filter(r => inferLevel(r) === level);
        }

        // Filter by coverage (impl or verify)
        if (filter === 'impl') {
          rules = rules.filter(r => r.implRefs.length === 0);
        } else if (filter === 'verify') {
          rules = rules.filter(r => r.verifyRefs.length === 0);
        }

        // Filter by search
        if (search) {
          const q = search.toLowerCase();
          rules = rules.filter(r =>
            r.id.toLowerCase().includes(q) ||
            (r.text && r.text.toLowerCase().includes(q))
          );
        }

        return rules;
      }, [allRules, search, level, filter, inferLevel]);

      const stats = useMemo(() => {
        // Stats are based on level-filtered rules (not coverage filter)
        let rules = allRules;
        if (level !== 'all') {
          rules = rules.filter(r => inferLevel(r) === level);
        }
        const total = rules.length;
        const impl = rules.filter(r => r.implRefs.length > 0).length;
        const verify = rules.filter(r => r.verifyRefs.length > 0).length;
        return {
          total,
          impl,
          verify,
          implPct: total ? (impl / total) * 100 : 0,
          verifyPct: total ? (verify / total) * 100 : 0,
        };
      }, [allRules, level, inferLevel]);

      // Markdown icon
      const mdIcon = html`<svg class="rule-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 3v4a1 1 0 0 0 1 1h4"/><path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2z"/><path d="M9 15l2 2 4-4"/></svg>`;

      return html`
        <div class="stats-bar">
          <div class="stat">
            <span class="stat-label">Rules</span>
            <span class="stat-value">${stats.total}</span>
          </div>
          <div class="stat clickable" onClick=${() => onFilterChange(filter === 'impl' ? null : 'impl')}>
            <span class="stat-label">Impl Coverage ${filter === 'impl' ? '(filtered)' : ''}</span>
            <span class="stat-value ${getStatClass(stats.implPct)}">${stats.implPct.toFixed(1)}%</span>
          </div>
          <div class="stat clickable" onClick=${() => onFilterChange(filter === 'verify' ? null : 'verify')}>
            <span class="stat-label">Test Coverage ${filter === 'verify' ? '(filtered)' : ''}</span>
            <span class="stat-value ${getStatClass(stats.verifyPct)}">${stats.verifyPct.toFixed(1)}%</span>
          </div>

          <!-- Level dropdown -->
          <div class="custom-dropdown ${levelOpen ? 'open' : ''}" id="level-dropdown">
            <div class="dropdown-selected" onClick=${(e) => { e.stopPropagation(); setLevelOpen(!levelOpen); }}>
              <span class="level-dot ${LEVELS[level].dotClass}"></span>
              <span>${LEVELS[level].name}</span>
              <svg class="chevron" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
            </div>
            <div class="dropdown-menu">
              ${Object.entries(LEVELS).map(([key, cfg]) => html`
                <div
                  key=${key}
                  class="dropdown-option ${level === key ? 'active' : ''}"
                  onClick=${() => { onLevelChange(key); setLevelOpen(false); }}
                >
                  <span class="level-dot ${cfg.dotClass}"></span>
                  <span>${cfg.name}</span>
                </div>
              `)}
            </div>
          </div>
        </div>
        <div class="main">
          <div class="content">
            <div class="content-body">
              <table class="rules-table">
                <thead>
                  <tr>
                    <th style="width: 45%">Rule</th>
                    <th style="width: 55%">References</th>
                  </tr>
                </thead>
                <tbody>
                  ${filteredRules.map(rule => html`
                    <tr key=${rule.id} onClick=${() => onSelectRule(rule.id)} style="cursor: pointer;">
                      <td>
                        <div class="rule-id-row">
                          ${mdIcon}
                          <span class="rule-id">${rule.id}</span>
                        </div>
                        ${rule.text && html`<div class="rule-text" dangerouslySetInnerHTML=${{ __html: renderRuleText(rule.text) }} />`}
                      </td>
                      <td class="rule-refs" onClick=${(e) => e.stopPropagation()}>
                        ${rule.implRefs.length > 0 || rule.verifyRefs.length > 0
                          ? html`
                              ${rule.implRefs.map(r => html`
                                <${FileRef}
                                  key=${'impl:' + r.file + ':' + r.line}
                                  file=${r.file}
                                  line=${r.line}
                                  type="impl"
                                  onSelectFile=${onSelectFile}
                                />
                              `)}
                              ${rule.verifyRefs.map(r => html`
                                <${FileRef}
                                  key=${'verify:' + r.file + ':' + r.line}
                                  file=${r.file}
                                  line=${r.line}
                                  type="verify"
                                  onSelectFile=${onSelectFile}
                                />
                              `)}
                            `
                          : html`<span style="color: var(--fg-dim)">â€”</span>`
                        }
                      </td>
                    </tr>
                  `)}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      `;
    }

    function SourcesView({ data, forward, config, search, selectedFile, selectedLine, ruleContext, onSelectFile, onSelectRule, onClearContext }) {
      const fileTree = useMemo(() => buildFileTree(data.files), [data.files]);
      const file = useFile(selectedFile);

      // Find the rule data if we have a context
      const contextRule = useMemo(() => {
        if (!ruleContext || !forward) return null;
        for (const spec of forward.specs) {
          const rule = spec.rules.find(r => r.id === ruleContext);
          if (rule) return rule;
        }
        return null;
      }, [ruleContext, forward]);

      const stats = {
        total: data.totalUnits,
        covered: data.coveredUnits,
        pct: data.totalUnits ? (data.coveredUnits / data.totalUnits) * 100 : 0,
      };

      // Check if a ref matches the current file:line
      const isActiveRef = useCallback((ref) => {
        return ref.file === selectedFile && ref.line === selectedLine;
      }, [selectedFile, selectedLine]);

      // Icons
      const closeIcon = html`<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18M6 6l12 12"/></svg>`;
      const backIcon = html`<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>`;

      return html`
        <div class="stats-bar">
          <div class="stat">
            <span class="stat-label">Code Units</span>
            <span class="stat-value">${stats.total}</span>
          </div>
          <div class="stat">
            <span class="stat-label">Spec Coverage</span>
            <span class="stat-value ${getStatClass(stats.pct)}">${stats.pct.toFixed(1)}%</span>
          </div>
          <div class="stat">
            <span class="stat-label">Covered</span>
            <span class="stat-value good">${stats.covered}</span>
          </div>
          <div class="stat">
            <span class="stat-label">Uncovered</span>
            <span class="stat-value ${stats.total - stats.covered > 0 ? 'bad' : 'good'}">${stats.total - stats.covered}</span>
          </div>
        </div>
        <div class="main">
          <div class="sidebar">
            ${contextRule ? html`
              <!-- Rule context panel -->
              <div class="rule-context">
                <div class="rule-context-header">
                  <span class="rule-context-id">${contextRule.id}</span>
                  <button class="rule-context-close" onClick=${onClearContext} title="Close context">
                    ${closeIcon}
                  </button>
                </div>
                <div class="rule-context-body">
                  ${contextRule.text && html`
                    <div class="rule-context-text">${contextRule.text}</div>
                  `}
                  <div class="rule-context-refs">
                    ${contextRule.implRefs.map(ref => html`
                      <div
                        key=${'impl:' + ref.file + ':' + ref.line}
                        class="rule-context-ref ${isActiveRef(ref) ? 'active' : ''}"
                        onClick=${() => onSelectFile(ref.file, ref.line, ruleContext)}
                        title=${ref.file}
                      >
                        <${FilePath} file=${ref.file} line=${ref.line} short type="impl" />
                      </div>
                    `)}
                    ${contextRule.verifyRefs.map(ref => html`
                      <div
                        key=${'verify:' + ref.file + ':' + ref.line}
                        class="rule-context-ref ${isActiveRef(ref) ? 'active' : ''}"
                        onClick=${() => onSelectFile(ref.file, ref.line, ruleContext)}
                        title=${ref.file}
                      >
                        <${FilePath} file=${ref.file} line=${ref.line} short type="verify" />
                      </div>
                    `)}
                  </div>
                  <a class="rule-context-back" onClick=${() => onSelectRule(ruleContext)}>
                    ${backIcon}
                    <span>Back to rule in spec</span>
                  </a>
                </div>
              </div>
            ` : html`
              <!-- Normal file tree -->
              <div class="sidebar-header">Files</div>
              <div class="sidebar-content">
                <${FileTree}
                  node=${fileTree}
                  selectedFile=${selectedFile}
                  onSelectFile=${onSelectFile}
                  search=${search}
                />
              </div>
            `}
          </div>
          <div class="content">
            ${file ? html`
              <div class="content-header">${file.path}</div>
              <div class="content-body">
                <${CodeView} file=${file} config=${config} selectedLine=${selectedLine} onSelectRule=${onSelectRule} />
              </div>
            ` : html`
              <div class="empty-state">Select a file to view coverage</div>
            `}
          </div>
        </div>
      `;
    }

    function FileTree({ node, selectedFile, onSelectFile, depth = 0, search, parentPath = '' }) {
      // Check if selected file is in this subtree
      const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;
      const containsSelectedFile = selectedFile && selectedFile.startsWith(currentPath + '/');
      const hasSelectedFile = selectedFile && (containsSelectedFile || node.files.some(f => f.path === selectedFile));

      const [open, setOpen] = useState(depth < 2 || hasSelectedFile);

      // Auto-expand when selected file changes to be in this subtree
      useEffect(() => {
        if (hasSelectedFile && !open) {
          setOpen(true);
        }
      }, [selectedFile, hasSelectedFile]);

      const folders = Object.values(node.children).sort((a, b) => a.name.localeCompare(b.name));
      const files = node.files.sort((a, b) => a.name.localeCompare(b.name));

      // Filter if searching
      const matchesSearch = (path) => {
        if (!search) return true;
        return path.toLowerCase().includes(search.toLowerCase());
      };

      if (depth === 0) {
        return html`
          <div class="file-tree">
            ${folders.map(f => html`
              <${FileTree}
                key=${f.name}
                node=${f}
                selectedFile=${selectedFile}
                onSelectFile=${onSelectFile}
                depth=${depth + 1}
                search=${search}
                parentPath=""
              />
            `)}
            ${files.filter(f => matchesSearch(f.path)).map(f => html`
              <${FileTreeFile}
                key=${f.path}
                file=${f}
                selected=${selectedFile === f.path}
                onClick=${() => onSelectFile(f.path)}
              />
            `)}
          </div>
        `;
      }

      const hasMatchingFiles = files.some(f => matchesSearch(f.path)) ||
        folders.some(f => Object.values(f.children).length > 0 || f.files.some(ff => matchesSearch(ff.path)));

      if (search && !hasMatchingFiles) return null;

      const folderBadge = getCoverageBadge(node.coveredUnits, node.totalUnits);

      return html`
        <div class="tree-folder ${open ? 'open' : ''}">
          <div class="tree-folder-header" onClick=${() => setOpen(!open)}>
            <div class="tree-folder-left">
              <svg class="tree-folder-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 18l6-6-6-6"/>
              </svg>
              <span>${node.name}</span>
            </div>
            <span class="folder-badge ${folderBadge.class}">${folderBadge.text}</span>
          </div>
          <div class="tree-folder-children">
            ${folders.map(f => html`
              <${FileTree}
                key=${f.name}
                node=${f}
                selectedFile=${selectedFile}
                onSelectFile=${onSelectFile}
                depth=${depth + 1}
                search=${search}
                parentPath=${currentPath}
              />
            `)}
            ${files.filter(f => matchesSearch(f.path)).map(f => html`
              <${FileTreeFile}
                key=${f.path}
                file=${f}
                selected=${selectedFile === f.path}
                onClick=${() => onSelectFile(f.path)}
              />
            `)}
          </div>
        </div>
      `;
    }

    function FileTreeFile({ file, selected, onClick }) {
      const badge = getCoverageBadge(file.coveredUnits, file.totalUnits);

      return html`
        <div
          class="tree-file ${selected ? 'selected' : ''}"
          onClick=${onClick}
        >
          <${LangIcon} filePath=${file.name} className="tree-file-icon" />
          <span class="tree-file-name">${file.name}</span>
          <span class="tree-file-badge ${badge.class}">${badge.text}</span>
        </div>
      `;
    }

    function CodeView({ file, config, selectedLine, onSelectRule }) {
      const rawLines = file.content.split('\n');
      const highlightedLines = useHighlightedLines(file.content, 'rust');
      const [popoverLine, setPopoverLine] = useState(null);
      const [highlightedLineNum, setHighlightedLineNum] = useState(null);
      const codeViewRef = useRef(null);

      // Build line annotations
      const lineAnnotations = useMemo(() => {
        const annotations = new Map();
        for (const unit of file.units) {
          for (let line = unit.startLine; line <= unit.endLine; line++) {
            if (!annotations.has(line)) {
              annotations.set(line, { units: [], ruleRefs: new Set() });
            }
            const anno = annotations.get(line);
            anno.units.push(unit);
            for (const ref of unit.ruleRefs) {
              anno.ruleRefs.add(ref);
            }
          }
        }
        return annotations;
      }, [file]);

      // Use highlighted lines if available, otherwise show raw (escaped)
      const displayLines = highlightedLines || rawLines.map(line =>
        line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
      );

      // Full path for editor URLs
      const fullPath = config?.projectRoot ? `${config.projectRoot}/${file.path}` : file.path;

      // Scroll to selected line when it changes
      useEffect(() => {
        if (selectedLine && codeViewRef.current && displayLines) {
          // Use requestAnimationFrame to ensure DOM is rendered
          requestAnimationFrame(() => {
            const lineElement = codeViewRef.current?.querySelector(`[data-line="${selectedLine}"]`);
            if (lineElement) {
              const container = codeViewRef.current.closest('.content-body');
              if (container) {
                // Calculate position to leave ~5 lines above, plus extra for headers
                const lineHeight = lineElement.offsetHeight;
                const headerOffset = 120; // header + stats bar
                const targetScrollTop = lineElement.offsetTop - (lineHeight * 5) - headerOffset;
                container.scrollTo({ top: Math.max(0, targetScrollTop) });
              }
              // Highlight the line (permanent until navigation changes)
              setHighlightedLineNum(selectedLine);
            }
          });
        }
      }, [selectedLine, file.path, displayLines]);

      // Close popover when clicking outside
      useEffect(() => {
        const handleClick = (e) => {
          if (!e.target.closest('.line-popover') && !e.target.closest('.line-number')) {
            setPopoverLine(null);
          }
        };
        document.addEventListener('click', handleClick);
        return () => document.removeEventListener('click', handleClick);
      }, []);

      return html`
        <div class="code-view" ref=${codeViewRef}>
          ${displayLines.map((lineHtml, i) => {
            const lineNum = i + 1;
            const anno = lineAnnotations.get(lineNum);
            const covered = anno && anno.ruleRefs.size > 0;
            const inUnit = anno && anno.units.length > 0;
            const isHighlighted = highlightedLineNum === lineNum;

            return html`
              <div
                key=${lineNum}
                data-line=${lineNum}
                class="code-line ${inUnit ? (covered ? 'covered' : 'uncovered') : ''} ${isHighlighted ? 'highlighted' : ''}"
              >
                <span
                  class="line-number"
                  onClick=${(e) => { e.stopPropagation(); setPopoverLine(popoverLine === lineNum ? null : lineNum); }}
                >
                  ${lineNum}
                  ${popoverLine === lineNum && html`
                    <div class="line-popover">
                      ${Object.entries(EDITORS).map(([key, cfg]) => html`
                        <a
                          key=${key}
                          href=${cfg.urlTemplate(fullPath, lineNum)}
                          class="popover-btn"
                          title="Open in ${cfg.name}"
                        >
                          ${cfg.devicon
                            ? html`<i class="${cfg.devicon}"></i>`
                            : html`<span dangerouslySetInnerHTML=${{ __html: cfg.icon }}></span>`
                          }
                          <span>${cfg.name}</span>
                        </a>
                      `)}
                    </div>
                  `}
                </span>
                <span
                  class="line-content"
                  dangerouslySetInnerHTML=${{ __html: lineHtml || ' ' }}
                />
                ${anno && anno.ruleRefs.size > 0 && html`
                  <span class="line-annotations">
                    <span class="annotation-count" title=${[...anno.ruleRefs].join(', ')}>${anno.ruleRefs.size}</span>
                    <span class="annotation-badges">
                      ${[...anno.ruleRefs].map(ref => html`
                        <a
                          key=${ref}
                          class="annotation-badge"
                          href=${buildUrl('spec', { rule: ref })}
                          onClick=${(e) => { e.preventDefault(); onSelectRule(ref); }}
                        >${ref}</a>
                      `)}
                    </span>
                  </span>
                `}
              </div>
            `;
          })}
        </div>
      `;
    }

    function SpecView({ config, forward, selectedRule, onSelectRule, onSelectFile, scrollPosition, onScrollChange }) {
      const spec = useSpec(config.specs[0]?.name);
      const [activeHeading, setActiveHeading] = useState(null);
      const contentRef = useRef(null);
      const contentBodyRef = useRef(null);
      const initialScrollPosition = useRef(scrollPosition);

      // Build rule coverage map
      const ruleCoverage = useMemo(() => {
        const map = new Map();
        for (const s of forward.specs) {
          for (const r of s.rules) {
            const hasImpl = r.implRefs.length > 0;
            const hasVerify = r.verifyRefs.length > 0;
            map.set(r.id, {
              rule: r,
              status: hasImpl && hasVerify ? 'covered' : hasImpl || hasVerify ? 'partial' : 'uncovered'
            });
          }
        }
        return map;
      }, [forward]);

      // Extract headings from markdown and generate slugs
      const headings = useMemo(() => {
        if (!spec) return [];
        const result = [];
        const lines = spec.content.split('\n');
        for (const line of lines) {
          const match = line.match(/^(#{1,4})\s+(.+)$/);
          if (match) {
            const level = match[1].length;
            const text = match[2].trim();
            const slug = text.toLowerCase().replace(/[^\w]+/g, '-').replace(/^-|-$/g, '');
            result.push({ level, text, slug });
          }
        }
        return result;
      }, [spec]);

      // Process markdown to inject rule markers and add IDs to headings
      const processedContent = useMemo(() => {
        if (!spec) return '';
        let content = spec.content;

        // Replace r[rule.id] with styled markers + reference links
        // Only match at start of file or after a blank line, at the beginning of a line
        content = content.replace(/(^|\n\n)r\[([^\]]+)\]/g, (match, prefix, ruleId) => {
          const coverage = ruleCoverage.get(ruleId);
          const status = coverage?.status || 'uncovered';
          const rule = coverage?.rule;

          // Helper to get just filename from path
          const getFileName = (path) => path.split('/').pop();

          let refHtml = '';
          if (rule) {
            const allRefs = [];
            if (rule.implRefs && rule.implRefs.length > 0) {
              rule.implRefs.forEach(r => {
                const deviconClass = getDeviconClass(r.file);
                const iconHtml = deviconClass
                  ? `<i class="${deviconClass} spec-ref-icon"></i>`
                  : `<i data-lucide="file" class="spec-ref-icon"></i>`;
                allRefs.push(`<a class="spec-ref spec-ref-impl" href="/tree/${r.file}:${r.line}" data-file="${r.file}" data-line="${r.line}" title="${r.file}:${r.line}">${iconHtml}${getFileName(r.file)}:${r.line}</a>`);
              });
            }
            if (rule.verifyRefs && rule.verifyRefs.length > 0) {
              rule.verifyRefs.forEach(r => {
                const deviconClass = getDeviconClass(r.file);
                const iconHtml = deviconClass
                  ? `<i class="${deviconClass} spec-ref-icon"></i>`
                  : `<i data-lucide="file" class="spec-ref-icon"></i>`;
                allRefs.push(`<a class="spec-ref spec-ref-verify" href="/tree/${r.file}:${r.line}" data-file="${r.file}" data-line="${r.line}" title="${r.file}:${r.line}">${iconHtml}${getFileName(r.file)}:${r.line}</a>`);
              });
            }
            if (allRefs.length > 0) {
              refHtml = allRefs.join('');
            }
          }

          // Use Lucide icon for rule marker
          const icon = `<i data-lucide="file-check" class="rule-marker-icon"></i>`;

          // Use special markers that we'll process after markdown parsing
          return `${prefix}<!--RULE_START:${ruleId}:${status}--><a class="rule-marker ${status}" href="/spec/${ruleId}" data-rule="${ruleId}">${icon}${ruleId}</a>${refHtml ? `<div class="spec-refs">${refHtml}</div>` : ''}<!--RULE_CONTENT_START-->`;
        });

        let html = marked.parse(content);

        // Add IDs to headings
        headings.forEach(h => {
          // Match the heading tag and add id attribute
          const headingRegex = new RegExp(`(<h${h.level}>)(${h.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})(</h${h.level}>)`, 'i');
          html = html.replace(headingRegex, `<h${h.level} id="${h.slug}" data-slug="${h.slug}">$2$3`);
        });

        // Wrap rule blocks: find RULE_START marker, capture until next RULE_START or heading
        html = html.replace(/<!--RULE_START:([^:]+):([^-]+)-->([\s\S]*?)<!--RULE_CONTENT_START-->([\s\S]*?)(?=<!--RULE_START|<h[1-6]|$)/g,
          (match, ruleId, status, header, content) => {
            // Clean up paragraph wrapping - the content is usually wrapped in <p> tags
            return `<div class="rule-block rule-block-${status}"><div class="rule-block-header">${header}</div><div class="rule-block-content">${content.trim()}</div></div>`;
          }
        );

        return html;
      }, [spec, ruleCoverage, headings]);

      // Set up intersection observer for headings
      useEffect(() => {
        if (!contentRef.current || !contentBodyRef.current || headings.length === 0) return;

        // Small delay to ensure DOM is ready
        const timeoutId = setTimeout(() => {
          const headingElements = contentRef.current.querySelectorAll('h1[id], h2[id], h3[id], h4[id]');
          if (headingElements.length === 0) return;

          const observer = new IntersectionObserver(
            (entries) => {
              // Track which headings are visible
              const visibleHeadings = [];
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  visibleHeadings.push({
                    id: entry.target.id,
                    top: entry.boundingClientRect.top
                  });
                }
              });

              // Set the topmost visible heading as active
              if (visibleHeadings.length > 0) {
                visibleHeadings.sort((a, b) => a.top - b.top);
                setActiveHeading(visibleHeadings[0].id);
              }
            },
            {
              root: contentBodyRef.current,
              rootMargin: '-5% 0px -70% 0px',
              threshold: 0
            }
          );

          headingElements.forEach(el => observer.observe(el));

          // Set initial active heading
          if (headings.length > 0) {
            setActiveHeading(headings[0].slug);
          }

          return () => observer.disconnect();
        }, 100);

        return () => clearTimeout(timeoutId);
      }, [processedContent, headings]);

      // Track scroll position changes
      useEffect(() => {
        if (!contentBodyRef.current) return;

        const handleScroll = () => {
          if (onScrollChange) {
            onScrollChange(contentBodyRef.current.scrollTop);
          }
        };

        contentBodyRef.current.addEventListener('scroll', handleScroll, { passive: true });
        return () => contentBodyRef.current?.removeEventListener('scroll', handleScroll);
      }, [onScrollChange]);

      // Initialize Lucide icons after content renders
      useEffect(() => {
        if (processedContent && contentRef.current && typeof lucide !== 'undefined') {
          requestAnimationFrame(() => {
            lucide.createIcons({ nodes: contentRef.current.querySelectorAll('[data-lucide]') });
          });
        }
      }, [processedContent]);

      const scrollToHeading = useCallback((slug) => {
        if (!contentRef.current || !contentBodyRef.current) return;
        const el = contentRef.current.querySelector(`[id="${slug}"]`);
        if (el) {
          const targetScrollTop = el.offsetTop - 100;
          contentBodyRef.current.scrollTo({ top: Math.max(0, targetScrollTop) });
          setActiveHeading(slug);
        }
      }, []);

      // Handle clicks on headings, rule markers, and spec refs in the markdown
      useEffect(() => {
        if (!contentRef.current) return;

        const handleClick = (e) => {
          // Handle heading clicks
          const heading = e.target.closest('h1[id], h2[id], h3[id], h4[id]');
          if (heading) {
            const slug = heading.id;
            const url = `${window.location.origin}${window.location.pathname}#${slug}`;
            navigator.clipboard?.writeText(url);
            return;
          }

          // Handle rule marker clicks
          const ruleMarker = e.target.closest('a.rule-marker[data-rule]');
          if (ruleMarker) {
            e.preventDefault();
            const ruleId = ruleMarker.dataset.rule;
            onSelectRule(ruleId);
            return;
          }

          // Handle spec ref clicks - pass rule context
          const specRef = e.target.closest('a.spec-ref');
          if (specRef) {
            e.preventDefault();
            const file = specRef.dataset.file;
            const line = parseInt(specRef.dataset.line, 10);
            // Find the rule ID from the parent rule-block
            const ruleBlock = specRef.closest('.rule-block');
            const ruleMarker = ruleBlock?.querySelector('a.rule-marker[data-rule]');
            const ruleContext = ruleMarker?.dataset.rule || null;
            onSelectFile(file, line, ruleContext);
            return;
          }
        };

        contentRef.current.addEventListener('click', handleClick);
        return () => contentRef.current?.removeEventListener('click', handleClick);
      }, [processedContent, onSelectRule, onSelectFile]);

      // Scroll to selected rule, or restore scroll position
      useEffect(() => {
        if (!processedContent) return;

        // Use requestAnimationFrame to ensure DOM is updated after render
        let cancelled = false;
        requestAnimationFrame(() => {
          if (cancelled) return;
          // Double RAF to ensure layout is complete
          requestAnimationFrame(() => {
            if (cancelled || !contentRef.current || !contentBodyRef.current) return;

            if (selectedRule) {
              // Navigate to specific rule
              const ruleEl = contentRef.current.querySelector(`[data-rule="${selectedRule}"]`);
              if (ruleEl) {
                // Use getBoundingClientRect relative to the scroll container
                const containerRect = contentBodyRef.current.getBoundingClientRect();
                const ruleRect = ruleEl.getBoundingClientRect();
                const currentScroll = contentBodyRef.current.scrollTop;
                const targetScrollTop = currentScroll + (ruleRect.top - containerRect.top) - 150;
                contentBodyRef.current.scrollTo({ top: Math.max(0, targetScrollTop) });

                // Add highlight class
                ruleEl.classList.add('rule-marker-highlighted');

                // Remove highlight after animation
                setTimeout(() => {
                  ruleEl.classList.remove('rule-marker-highlighted');
                }, 3000);
              }
            } else if (initialScrollPosition.current > 0) {
              // Restore previous scroll position (only on initial mount)
              contentBodyRef.current.scrollTo({ top: initialScrollPosition.current });
              initialScrollPosition.current = 0; // Clear so we don't restore again
            }
          });
        });

        return () => { cancelled = true; };
      }, [selectedRule, processedContent]);

      if (!spec) {
        return html`
          <div class="main">
            <div class="empty-state">Loading spec...</div>
          </div>
        `;
      }

      return html`
        <div class="main">
          <div class="sidebar">
            <div class="sidebar-header">Outline</div>
            <div class="sidebar-content">
              <div class="outline-tree">
                ${headings.map(h => html`
                  <div
                    key=${h.slug}
                    class="outline-item outline-level-${h.level} ${activeHeading === h.slug ? 'active' : ''}"
                    onClick=${() => scrollToHeading(h.slug)}
                  >
                    ${h.text}
                  </div>
                `)}
              </div>
            </div>
          </div>
          <div class="content">
            <div class="content-header">
              ${spec.sourceFile || spec.name}
            </div>
            <div class="content-body" ref=${contentBodyRef}>
              <div
                class="markdown"
                ref=${contentRef}
                dangerouslySetInnerHTML=${{ __html: processedContent }}
              />
            </div>
          </div>
        </div>
      `;
    }

    // ========================================================================
    // Mount
    // ========================================================================

    render(html`<${App} />`, document.getElementById('app'));

    // Global keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        document.querySelector('.search-input')?.focus();
      }
    });
  </script>
</body>
</html>
